function i_ = set(i_, varargin)%set method for class dXimage: specify property values and recompute dependencies%   i_ = set(i_, varargin)%%   All DotsX classes have set methods which allow properties for one or%   more instances to be specified, and dependent values recomputed.%%   Updated class instances are always returned.%%----------Special comments-----------------------------------------------%-%%-% Overloaded set method for class dXimage%-%%-% Assigns properties to 'image' object(s)%-% and returns the updated object(s)%----------Special comments-----------------------------------------------%%   See also set dXimage% Copyright 2006 by Joshua I. Gold%   University of Pennsylvania% set the fields, one at a time.. no error checkingif length(i_) == 1    % set one object    for ii = 1:2:nargin-1        i_.(varargin{ii}) = varargin{ii+1};    endelse    % set many objects  ... a cell means separate    %   values given for each object; otherwise    %   the same value is set for all objects    inds=ones(size(i_));    for ii = 1:2:nargin-1        % change it        if iscell(varargin{ii+1}) && ~isempty(varargin{ii+1})            [i_.(varargin{ii})] = deal(varargin{ii+1}{:});        else            [i_.(varargin{ii})] = deal(varargin{ii+inds});        end    endend% quick loop to check/update visible propertyfor ii = 1:length(i_)    % check that any diameter is < 0; if so, set 'visible' to false    % also make sure visible is boolean    if i_(ii).scale <= 0 || i_(ii).visible < 1        i_(ii).visible = false;    else        i_(ii).visible = true;    endend% Special case of only 'visible' value set%   (and not first time through)if nargin == 3 && strcmp(varargin{1}, 'visible') && ~isempty(i_(1).sizes)    returnend% only recompute the texture when we have to%   i.e. when filename changesredoTexture = any(strcmp(varargin, 'windowNumber')) ...    || any(strcmp(varargin, 'file')) ...    || any(strcmp(varargin, 'imReadArgs')) ...    || any(strcmp(varargin, 'color')) ...    || any(strcmp(varargin, 'useTextures'));% loop. ugh.for ii = 1:length(i_)    % update only if scale > 0    if i_(ii).scale > 0        % "filename" can be:        %   a file with or without a dir (for a single image)        %   or just a dir (for a sequence to animate)        if isempty(i_(ii).dir)            i_(ii).filename = which(i_(ii).file);        else            i_(ii).filename = fullfile(i_(ii).dir, i_(ii).file);        end        % recompute texuture when filename changes,        %   or loaded from disk etc.        if redoTexture            if isdir(i_(ii).filename)                % read sequence of images                files         = dir(i_(ii).filename);                num_images    = length(files) - 2; % account for '.' and '..'                i_(ii).images = cell(num_images, 1);                i_(ii).sizes  = nan*ones(num_images, 2);                for nn = 1:num_images                    % read the image                    [img, map, alp] = imread(fullfile(i_(ii).dir, files(nn+2).name), ...                        i_(ii).imReadArgs{:});                    % concatenate the alpha channel, if it's there                    if ~isempty(alp) && all(size(img) == size(alp))                        i_(ii).images{nn} = cat(3, img, alp);                    else                        i_(ii).images{nn} = img;                    end                    i_(ii).sizes(nn,:) = [size(i_(ii).images{nn}, 1), ...                        size(i_(ii).images{nn}, 2)]./2;                end            else                % read single image, with possible alpha channel                num_images = 1;                [img, map, alp] = imread(i_(ii).filename, i_(ii).imReadArgs{:});                if ~isempty(alp) && all(size(img) == size(alp))                    i_(ii).images{1} = cat(3, img, alp);                else                    i_(ii).images{1} = img;                end                i_(ii).sizes      = [size(i_(ii).images{1}, 1), ...                    size(i_(ii).images{1}, 2)]./2;            end            % store num images            i_(ii).numImages = num_images;            % reset counters            i_(ii).index      = 1;            i_(ii).frameCount = 0;            % possibly convert to textures (fast) ...            global ROOT_STRUCT            if i_(ii).useTextures && ROOT_STRUCT.screenMode > 0                % reset array                i_(ii).textures = nan*ones(i_(ii).numImages, 1);                % loop again. ugh again. go through each image...                for nn = 1:i_(ii).numImages                    % possibly modulate the color of the image                    %   only deal with RGB modulating color                    if ~isempty(i_(ii).color) && length(i_(ii).color)==3                        % may need to expand gray image to RGB                        switch size(i_(ii).images{nn}, 3)                            case 1 % expand g to RGB                                img(:,:,3) = i_(ii).images{nn}(:,:,1);                                img(:,:,2) = i_(ii).images{nn}(:,:,1);                                img(:,:,1) = i_(ii).images{nn}(:,:,1);                            case 2 % expand ga to RGBa                                img(:,:,4) = i_(ii).images{nn}(:,:,2);                                img(:,:,3) = i_(ii).images{nn}(:,:,1);                                img(:,:,2) = i_(ii).images{nn}(:,:,1);                                img(:,:,1) = i_(ii).images{nn}(:,:,1);                        end                        % multiply each image plane by the modulating color                        img(:,:,3) = img(:,:,3)*i_(ii).color(3);                        img(:,:,2) = img(:,:,2)*i_(ii).color(2);                        img(:,:,1) = img(:,:,1)*i_(ii).color(1);                    else                        % none of that modulate color nonsense                        img = i_(ii).images{nn};                    end                    i_(ii).textures(nn) = Screen('MakeTexture', ...                        i_(ii).windowNumber, img);                end                % possibly pre-load                if i_(ii).preloadTextures                    Screen('PreloadTextures', i_(ii).windowNumber, ...                        i_(ii).textures);                end                % blank images array                i_(ii).images = {};            else                % blank textures array                i_(ii).textures = [];            end        end        % Compute destRec ...        %   2 easy cases:        %       x,y = 0,0 & scale = 1 : default        %       scale = inf : full screen        if i_(ii).x == 0 && i_(ii).y == 0 && i_(ii).scale == 1            i_(ii).drawRects = cell(i_(ii).numImages, 1);        elseif i_(ii).scale == inf            i_(ii).drawRects = mat2cell(repmat(i_(ii).screenRect, i_(ii).numImages, 1), ...                ones(1, i_(ii).numImages), 4);        else            x0 = i_(ii).sr(1) + i_(ii).x*i_(ii).pixelsPerDegree;            y0 = i_(ii).sr(2) - i_(ii).y*i_(ii).pixelsPerDegree;            i_(ii).drawRects = cell(i_(ii).numImages, 1);            for nn = 1:i_(ii).numImages                sz = i_(ii).sizes(nn,:) * i_(ii).scale;                i_(ii).drawRects{nn} = [ ...                    x0 - sz(2), ...                    y0 - sz(1), ...                    x0 + sz(2), ...                    y0 + sz(1)];            end        end    endend