function t_ = set(t_, varargin)%set method for class dXtargets: specify property values and recompute dependencies%   t_ = set(t_, varargin)%%   All DotsX classes have set methods which allow properties for one or%   more instances to be specified, and dependent values recomputed.%%   Updated class instances are always returned.%%----------Special comments-----------------------------------------------%-%%-% Overloaded set method for class dXtarget%-%%-% Assigns properties to 'target' object(s)%-% and returns the updated object(s)%----------Special comments-----------------------------------------------%%   See also set dXtargets% Copyright 2004 by Joshua I. Gold%   University of Pennsylvania% set the fields, one at a time.. no error checkingif length(t_) == 1    % set one object    for ii = 1:2:nargin-1        t_.(varargin{ii}) = varargin{ii+1};    endelse    % set many objects  ... a cell means separate    %   values given for each object; otherwise    %   the same value is set for all objects    inds=ones(size(t_));    for ii = 1:2:nargin-1        % change it        if iscell(varargin{ii+1}) && ~isempty(varargin{ii+1})            [t_.(varargin{ii})] = deal(varargin{ii+1}{:});        else            [t_.(varargin{ii})] = deal(varargin{ii+inds});        end    endend% useful variablessr  = t_(1).sr;ppd = t_(1).pixelsPerDegree;% loop through each targetfor tind = 1:length(t_)    % check up on color    if any((strcmp(varargin(1:2:end), 'color')))        % resolve pointer or lumanance to rgb triple        t_(tind).color = rGraphicsGetRGB(t_(tind).color);        % Might need to reshape color array ...        %   CLUT indices are columns, rgb triples are rows        if size(t_(tind).color, 2) ~= 3 && size(t_(tind).color, 2) ~= 1            t_(tind).color = t_(tind).color';        end    end    % check for lengths of key parameters    num_targets = max([length(t_(tind).x) length(t_(tind).y) ...        length(t_(tind).diameter) length(t_(tind).cmd) ...        length(t_(tind).penWidth) size(t_(tind).color, 1)]);    if num_targets > 1        if length(t_(tind).x) == 1            t_(tind).x = repmat(t_(tind).x, num_targets, 1);        elseif size(t_(tind).x, 2) > 1            t_(tind).x = t_(tind).x(:);        end        if length(t_(tind).y) == 1            t_(tind).y = repmat(t_(tind).y, num_targets, 1);        elseif size(t_(tind).y, 2) > 1            t_(tind).y = t_(tind).y(:);        end        if length(t_(tind).diameter) == 1            t_(tind).diameter = repmat(t_(tind).diameter, num_targets, 1);        elseif size(t_(tind).diameter, 2) > 1            t_(tind).diameter = t_(tind).diameter(:);        end        if length(t_(tind).cmd) == 1            t_(tind).cmd = repmat(t_(tind).cmd, num_targets, 1);        elseif size(t_(tind).cmd, 2) > 1            t_(tind).cmd = t_(tind).cmd(:);        end        if size(t_(tind).color, 1) == 1            t_(tind).color = repmat(t_(tind).color, num_targets, 1);        elseif size(t_(tind).color, 1) > 1            % what is the point of this?            t_(tind).color = t_(tind).color(:,:);        end    end    % check whether all diameters are <= 0    if all(t_(tind).diameter <= 0)        % if so, set 'visible' to 0        t_(tind).visible = false;    else        % make 'visible' value logical        t_(tind).visible = logical(t_(tind).visible);        % compute the drawRects relative to the center of the screen        d_ppd = t_(tind).diameter.*ppd;        x0	  = sr(1)+t_(tind).x.*ppd-0.5*d_ppd;        y0    = sr(2)-t_(tind).y.*ppd-0.5*d_ppd;        t_(tind).drawRect = [x0 y0 (x0 + d_ppd) (y0 + d_ppd)];    endend