function b_ = set(b_, varargin)%set method for class dXbar: specify property values and recompute dependencies%   b_ = set(b_, varargin)%%   All DotsX classes have set methods which allow properties for one or%   more instances to be specified, and dependent values recomputed.%%   Updated class instances are always returned.%%----------Special comments-----------------------------------------------%-%%-% Overloaded set method for class dXbar%-%%-% Assigns properties to 'dXbar' object(s)%-% and returns the updated object(s)%----------Special comments-----------------------------------------------%%   See also set dXbar% Copyright 2004 by Joshua I. Gold%   University of Pennsylvania% set the fields, one at a time..% set many objects  ... a cell means separate%   values given for each object; otherwise%   the same value is set for all objects% set the fields, one at a time.. no error checkingif length(b_) == 1    % set one object    for ii = 1:2:nargin-1        b_.(varargin{ii}) = varargin{ii+1};    endelse    % set many objects  ... a cell means separate    %   values given for each object; otherwise    %   the same value is set for all objects    inds=ones(size(b_));    for ii = 1:2:nargin-1        % change it        if iscell(varargin{ii+1}) && ~isempty(varargin{ii+1})            [b_.(varargin{ii})] = deal(varargin{ii+1}{:});        else            [b_.(varargin{ii})] = deal(varargin{ii+inds});        end    endend% Create an upright rectangle texture,%   rotate it at draw time with openGLwn = b_(1).windowNumber;ppd = b_(1).pixelsPerDegree;sr = b_(1).screenRect;wins = Screen('Windows');if wn >= 0    for ii = 1:length(b_)        % convert degrees to pixels?        %   move origin from center to up-left corner        %   invert the y-axis        if strcmp(b_(ii).units, 'degrees')            w = max(b_(ii).w*ppd, 1);            h = max(b_(ii).h*ppd, 1);            x = b_(ii).ctrX*ppd + sr(3)/2 - w/2;            y = sr(4)/2 - b_(ii).ctrY*ppd - h/2;        else            w = max(b_(ii).w, 1);            h = max(b_(ii).h, 1);            x = b_(ii).ctrX + sr(3)/2 - w/2;            y = sr(4)/2 - b_(ii).ctrY - h/2;        end        % where to put the texture onscreen        b_(ii).destinationRect = [x, y, x+w-1, y+h-1];        % check if we need to get a texture        if ~isempty(wins) && ~any(b_(ii).texture == wins)            % check it we can reuse texture from first instance            %   which only depends on color            if ~isnan(b_(1).texture) && isequal(b_(ii).color, b_(1).color)                b_(ii).texture = b_(1).texture;                b_(ii).texImage = b_(1).texImage;            else                % texture image is 10 by 10 by 4-color                %   10 is an arbitrary, dumb size                %   actual size is determined by stretching to destinationRect                %   four colors are red, green, blue, transparency                tex = ones(b_(ii).texSide, b_(ii).texSide, 4);                c = clutX(b_(ii).color);                tex(:,:,1) = tex(:,:,1)*c(1);                tex(:,:,2) = tex(:,:,2)*c(2);                tex(:,:,3) = tex(:,:,3)*c(3);                % use specified transparency or default to opaque                if length(c) > 3                    tex(:,:,4) = tex(:,:,4)*c(4);                else                    tex(:,:,4) = tex(:,:,4)*255;                end                % type 'Screen MakeTexture?' for details.                b_(ii).texture = Screen('MakeTexture', wn, tex, 0, 1);                b_(ii).texImage = tex;            end        end    endend