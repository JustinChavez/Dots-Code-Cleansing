function p_ = set(p_, varargin)%set method for class dXpolygon: specify property values and recompute dependencies%   p_ = set(p_, varargin)%%   All DotsX classes have set methods which allow properties for one or%   more instances to be specified, and dependent values recomputed.%%   Updated class instances are always returned.%%----------Special comments-----------------------------------------------%-%%-% Overloaded set method for class dXpolygon%-%%-% Assigns properties to 'target' object(s)%-% and returns the updated object(s)%----------Special comments-----------------------------------------------%%   See also set dXpolygon% Copyright 2008 by Joshua I. Gold%   University of Pennsylvania% set the fields, one at a time.. no error checkingif length(p_) == 1    % set one object    for ii = 1:2:nargin-1        p_.(varargin{ii}) = varargin{ii+1};    endelse    % set many objects  ... a cell means separate    %   values given for each object; otherwise    %   the same value is set for all objects    inds=ones(size(p_));    for ii = 1:2:nargin-1        % change it        if iscell(varargin{ii+1}) && ~isempty(varargin{ii+1})            [p_.(varargin{ii})] = deal(varargin{ii+1}{:});        else            [p_.(varargin{ii})] = deal(varargin{ii+inds});        end    endend% quick loop to check/update visible and color propertiesfor ii = 1:length(p_)    % check that any diameter is < 0; if so, set 'visible' to false    % also make sure visible is boolean    if isempty(p_(ii).pointList) || p_(ii).visible < 1        p_(ii).visible = false;    else        p_(ii).visible = true;    end    % resolve pointer or lumanance to rgb triple    p_(ii).color = rGraphicsGetRGB(p_(ii).color);end% quick exitif nargin == 3 && strcmp(varargin{1}, 'visible') && ...        ~isempty(p_(1).pList)    returnend% convert pointList to screen coordinates, relative% to the center of the screenfor ii = 1:length(p_)    if size(p_(ii).pointList, 2) >= 2        p_(ii).pList = [ ...            p_(1).sr(1)+p_(ii).pointList(:,1).*p_(1).pixelsPerDegree, ...            p_(1).sr(2)-p_(ii).pointList(:,2).*p_(1).pixelsPerDegree];    endend