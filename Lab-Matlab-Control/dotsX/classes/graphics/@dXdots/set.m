function d_ = set(d_, varargin)%set method for class dXdots: specify property values and recompute dependencies%   d_ = set(d_, varargin)%%   All DotsX classes have set methods which allow properties for one or%   more instances to be specified, and dependent values recomputed.%%   Updated class instances are always returned.%%----------Special comments-----------------------------------------------%-%%-% Overloaded set method for class dXdots%-%%-% Assigns properties to 'dXdots' object(s)%-% and returns the updated object(s)%----------Special comments-----------------------------------------------%%   See also set dXdots% 7/13/06 .. jig changed pts from columns%   to rows, to account for new SCREENDots routine% 30 April 2008 BSH added arbitrary dot direction distribution% Copyright 2004 by Joshua I. Gold%   University of Pennsylvania% set the fields, one at a time.. no error checkingif length(d_) == 1    % set one object    for ii = 1:2:nargin-1        d_.(varargin{ii}) = varargin{ii+1};    endelse    % set many objects  ... a cell means separate    %   values given for each object; otherwise    %   the same value is set for all objects    inds=ones(size(d_));    for ii = 1:2:nargin-1        % change it        if iscell(varargin{ii+1}) && ~isempty(varargin{ii+1})            [d_.(varargin{ii})] = deal(varargin{ii+1}{:});        else            [d_.(varargin{ii})] = deal(varargin{ii+inds});        end    endend% quick loop to check/update coherence visible, color propertiesfor ii = 1:length(d_)    % coh is saved as 0 ... 99.9; we want 0 ... 0.999    d_(ii).dotCoh = d_(ii).coherence/100;    % check that any diameter is < 0; if so, set 'visible' to false    % also make sure visible is boolean    if d_(ii).diameter <= 0 || d_(ii).visible < 1        d_(ii).visible = false;    else        d_(ii).visible = true;    end    % resolve pointer or lumanance to rgb triple    d_(ii).color = rGraphicsGetRGB(d_(ii).color);end% be quick for visible toggleif nargin == 3 && strcmp(varargin{1}, 'visible') && ...        ~isempty(d_(1).pts)    returnend% only recompute random distribution data when we have to%   i.e. when size, speed, or direction distribution changesredoDistribution = any(strcmp(varargin, 'dirCDF')) ...    || any(strcmp(varargin, 'dirDomain')) ...    || any(strcmp(varargin, 'speed')) ...    || any(strcmp(varargin, 'diameter')) ...    || any(strcmp(varargin, 'apScale')) ...    || any(strcmp(varargin, 'frameRate'));% only recompute the aperture texture when we have to%   i.e. when size or position changesredoTexture = any(strcmp(varargin, 'windowNumber')) ...    || any(strcmp(varargin, 'x')) ...    || any(strcmp(varargin, 'y')) ...    || any(strcmp(varargin, 'diameter')) ...    || any(strcmp(varargin, 'size')) ...    || any(strcmp(varargin, 'apScale')) ...    || any(strcmp(varargin, 'pixelsPerDegree')) ...    || any(strcmp(varargin, 'screenRect'));% compute apRect, drawRect% note that what we define as x,y,diameter for the aperture% is the *visible* aperture (apRect); the "drawRect" defines the% rectangle that we're drawing the texture to on the screend_ppd = 0.5*vertcat(d_.diameter)*d_(1).pixelsPerDegree;x0	  = d_(1).screenRect(3)/2+vertcat(d_.x).*d_(1).pixelsPerDegree;y0    = d_(1).screenRect(4)/2-vertcat(d_.y).*d_(1).pixelsPerDegree;arect = [x0-d_ppd y0-d_ppd x0+d_ppd y0+d_ppd];d_ppd = d_ppd.*vertcat(d_.apScale);drect = [x0-d_ppd y0-d_ppd x0+d_ppd y0+d_ppd];% seed the random number generator%   for now, just use the seed of the first objectif isempty(d_(1).seed) || d_(1).seed==0    rand('state', sum(100*clock));else    rand('state', prod(d_(1).seed));end% loop through all the dXdots objectsfor ii = 1:length(d_)    %%%    % Compute parameters needed for drawing dots, but only    %   if diameter > 0    %%%    if d_(ii).diameter > 0        % drawRect is rect on screen where dots will be drawn        d_(ii).drawRect = drect(ii, :);        % drawSize is draw rect diameter, converted back into degrees        d_(ii).drawSize = d_(ii).diameter*d_(ii).apScale;        % apRect is the rectangle circumscribed about the        %   circular aperture in which dots will be visible.        %   It's smaller than, centered in drawRect.        d_(ii).apRect = arect(ii, :);        % nDots is the number of dots shown per video frame        % we will place dots in a square the size of the aperture        % - Size of aperture = Apd*Apd/100  sq deg        % - Number of dots per video frame = 16.7 dots per sq.deg/sec,        %        Round up, do not exceed the number of dots that can be        %		 plotted in a video frame (maxPerFrame)        d_(ii).nDots = ...            min([d_(ii).maxPerFrame, ...            ceil(d_(ii).density * ((d_(ii).drawSize)^2) / d_(1).frameRate)]);        nDots = d_(ii).nDots*d_(ii).loops;        % jumpSize is in fraction_of_aperture per sec:        %   speed (deg/sec) * 1/(deg/aperture) * sec/jump = ap/jump        d_(ii).jumpSize = ...            (d_(ii).speed) * (1/(d_(ii).drawSize)) * (d_(ii).loops/d_(1).frameRate);        % dxdy specifies x,y offsets for the given jumpSize and dot Direction        d_(ii).dxdy = [cos(pi*d_(ii).direction/180.0); -sin(pi*d_(ii).direction/180.0)] * ...            ones(1, nDots) * d_(ii).jumpSize;        % divide dots into "loop" sets...        d_(ii).loopIndex = 0;        % Each loop contains 3 cols of data for each dot:        %   - x start position (random)        %   - y start position (random)        %   - lifetime (used if lifetimeMode is set to 'limit')        d_(ii).pts = [rand(2, nDots); zeros(1, nDots)];        % create selection matrix for dots        d_(ii).Lpts = reshape(1:nDots,d_(ii).nDots,d_(ii).loops)';        % calculate inverse of dot direction CDF.        %   This allows indexing of directions with uniform rand        %   It also allows indexing of dX and dY with same        if (isempty(d_(ii).dirCDFInv) || redoDistribution) ...                && ~isempty(d_(ii).dirCDF) ...                && ~isempty(d_(ii).dirDomain)            % normalize the CDF by its maximum            d_(ii).dirCDF = d_(ii).dirCDF / max(d_(ii).dirCDF);            % the CDF inverse is a lookup table            %   over many evenly spaced probabilities            d_(ii).dirCDFInv = zeros(1,d_(ii).nP);            d_(ii).dxdyDomain = zeros(2,d_(ii).nP);            p = linspace(0, 1, d_(ii).nP);            for jj = 1:d_(ii).nP                % find the next neighbor to each p in the CDF                ind = find(d_(ii).dirCDF >= p(jj), 1, 'first');                % use the corresponding direction value                %   expect duplicate directions in the correct proportions                d_(ii).dirCDFInv(jj) = d_(ii).dirDomain(ind);                % calculate dX and dY for this direction, given jump size                d_(ii).dxdyDomain(:,jj) = d_(ii).jumpSize * ...                    [cos(pi*d_(ii).dirCDFInv(jj)/180.0); ...                    -sin(pi*d_(ii).dirCDFInv(jj)/180.0)];            end        end        if isempty(d_(ii).maskImage) || redoTexture            % Width in pixels of drawing rect.            d_(ii).drawSizePix = d_(ii).drawRect(3)-d_(ii).drawRect(1);            % get width of mask for showing dots in circular aperture            %   since dots are drawn on-center, include dot width            maskSize = d_(ii).size + ceil(d_(ii).drawSizePix);            % compute RGBA white square,            %   and cut a hole in the alpha channel            %   final color can be poked in at draw time            marginal  = exp(linspace(-1,1,maskSize).^2);            maskAlpha = marginal'*marginal;            thresh    = maskAlpha(round(maskSize/2), ...                round((maskSize-maskSize/d_(ii).apScale)/2));            d_(ii).maskImage = zeros(maskSize, maskSize, 4);            d_(ii).maskImage(:,:,1) = d_(ii).bgColor(1);            d_(ii).maskImage(:,:,2) = d_(ii).bgColor(2);            d_(ii).maskImage(:,:,3) = d_(ii).bgColor(3);            d_(ii).maskImage(:,:,4) = (maskAlpha >= thresh)*255;                        % specify the full extent of the mask when drawing            d_(ii).maskSource = [0,0,maskSize,maskSize];            % real estate of mask is a little greater than that of dots            %   be sure maskSource and maskRect are the same size            %   because stretching could only waste GPU time            d_(ii).maskRect = d_(ii).maskSource ...                + d_(ii).drawRect([1 2 1 2]) - d_(ii).size/2;            if ~isempty(d_(ii).maskImage)                % if in local draw mode, save mask as openGL texture                global ROOT_STRUCT                if ROOT_STRUCT.screenMode == 1                    % send image data to video card                    d_(ii).maskTexindex = Screen('MakeTexture', ...                        d_(ii).windowNumber, d_(ii).maskImage);                    % load texture into fast video memory (as available)                    Screen('PreloadTextures', d_(ii).windowNumber);                    % try to draw dots before other objects                    %   so the mask doesn't get in the way                    if isfield(ROOT_STRUCT.methods, 'draw')                        doti = strcmp(ROOT_STRUCT.methods.draw, 'dXdots');                        ROOT_STRUCT.methods.draw = cat(2, ...                            ROOT_STRUCT.methods.draw(doti), ...                            ROOT_STRUCT.methods.draw(~doti));                    end                end            end        end        % warn about saving debugging data        if d_(ii).debugSavePts            warning(sprintf('dXdots #%d is using debugSavePts mode!\n This is a SLOW DEBUGGING feature.', ii))        end        %%%% FOR TEXTURES ... NOT IMPLEMENTED %%%%%%        %%%        % possibly pre-compute the dots, as textures        %%%        % if d_(ii).preCompute        %        %     % get number of frames        %     % if preCompute > 0, then that specifies the # of frames        %     % otherwise use duration        %     if d_(ii).preCompute > 0        %         numFrames = d_(ii).preCompute;        %     else        %         numFrames = d_(ii).duration / 1000 * d_(1).frameRate;        %     end        %        %     % set the pointer        %     if numFrames > 0        %         d_(ii).textureIndex = 1;        %     end        %        %     % alloc the img matrix        %     MAX_DOT_SIZE = 10;        %     d_(ii).destSize = ...        %         [ceil(drect(ii,4)-drect(ii,2)) ceil(drect(ii,4)-drect(ii,2))];        %     imgHt   = d_(ii).destSize(1) + MAX_DOT_SIZE;        %     imgWid  = d_(ii).destSize(2) + MAX_DOT_SIZE;        %     img     = uint8(zeros(imgHt, imgWid));        %        %     % alloc dots matrix        %     pts = zeros(5, nDots);        %        %     % alloc textures array        %     d_(ii).textures = zeros(numFrames,1);        %        %     % loop index        %     d_(ii).loopIndex = 1;        %        %     % background color        %     bg = rGet('dXscreen', 1, 'bgColor');        %        %     for fr = 1:numFrames        %        %         % get the dots        %         pts = makePts(d_(ii));        %        %         % save the dots and update the loop pointer        %         d_(ii).pts(:,:,d_(ii).loopIndex) = pts;        %         d_(ii).loopIndex = d_(ii).loopIndex + 1;        %         if d_(ii).loopIndex > d_(ii).loops        %             d_(ii).loopIndex = 1;        %         end        %        %         % scale the dots        %         pts(1,:) = round(pts(1,:) * (d_(ii).destSize(1)));        %         pts(2,:) = round(pts(2,:) * (d_(ii).destSize(2)));        %         pts(pts(1:2,:)==0) = 1;        %        %         % clear the img        %         img(:) = bg;        %        %         % loop through dot size        %         for dt = 1:min(max(pts(4,:)), MAX_DOT_SIZE)        %             Ld = pts(4,:) >= dt;        %             img((pts(2,Ld)+dt-1)+(pts(1,Ld)+dt-2)*imgHt) = pts(3,Ld);        %             for j = 0:dt-2        %                 img([(pts(2,Ld)+j)+(pts(1,Ld)+dt-2)*imgHt; ...        %                     (pts(2,Ld)+dt-1)+(pts(1,Ld)+j-1)*imgHt]) = [pts(3,Ld) pts(3,Ld)];        %             end        %         end        %        %         % make the texture        %         d_(ii).textures(fr) = ...        %             Screen('MakeTexture', max(Screen('Screens')), ...        %             img(1:d_(ii).destSize(1), ...        %             1:d_(ii).destSize(2)));        %     end        % end    endend