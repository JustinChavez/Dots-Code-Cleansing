function inds_ = rAdd(class_name, varargin)%   inds_ = rAdd(class_name, varargin)%%   rAdd adds objects of the given type to the global ROOT_STRUCT.%   Usage:%       rAdd('<class_name>', *<number>,  *{<args>}, *property/value pairs ...)%       *optional arguments%       args are group_name, reuse_flag, call_set_now_flag,%       call_set_later_flat%%   Arguments:%       class_name is a string that specifies the name of a dotsX class,%           such as 'dXDots'.%%       num_objects is an (optional) scalar that specifies how many%           instances of 'class_name' to add.  By default 1 instance is added.%%       args is an (optional) cell array with the following entries:%           group_name ... STRING name of the group in which to add%                           the object(s). '' for none, 'current' (default)%                           for current%           reuse      ... BOOLEAN, whether or not to try%           call_set   ... BOOLEAN, whether or not to call set method.%                           default true.%           save_set   ... BOOLEAN, whether or not to save, along%                           with other data for the current group,%                           any property-value pairs included as%                           the last elements of varargin.  If TRUE,%                           when rGroup activates these class instances,%                           it will invoke their set method with the%                           saved arguments.  Default false:%                           arguments will not be saved.%%           Additional property-value pairs may be included as the last%               elements of varargin.  When each class instance is created,%               its set method will be invoked with these arguments.%%   rAdd returns inds_, an array of indices specifing the created objects.%%   The following creates dXdots instances using various modes of rAdd.%%   % use default values only%   rInit('debug');%   default_instance = rAdd('dXdots')%%   % specify a green color for several instances%   green_instances = rAdd('dXdots', 3, 'color', [0,0,200])%%   % fully specify group behavior for several instances%   %   note that instances 1-4 are resued%   rGroup('fast');%   fast_instances = rAdd('dXdots', 6, {[], true, true}, 'speed', 12)%%   See also rGroup dXdots rInit rClear rSet% Copyright 2005 by Joshua I. Gold%   University of Pennsylvaniaglobal ROOT_STRUCT% default outputinds_ = [];%%%% check arguments%%%%%% First optional argument is the number of objectsnum_objects = 1;if size(varargin, 2) >= 1 && isscalar(varargin{1})    num_objects = varargin{1};    if num_objects <= 0        return    end    varargin(1) = [];end%%% Second optional arg is a CELL ARRAY of additional%   specifiers:%       group_name ... STRING name of group%                      [] or '' or 'current' means current group%                      'root' means root (i.e., no) group%       group_index... INT group index in ROOT_STRUCT.groups.(name) array%       reuse      ... BOOLEAN, whether or not to try to reuse%                       existing objects%       set now    ... BOOLEAN, whether or not%                       to call 'set' method here; if not,%                       you can still store the set args in%                       the group specifier (if there is a group)%                       and call set later%       set later   ... BOOLEAN, whether or not to call set with%                       the set args later; i.e., every time the%                       group is made active%%% Check for special classes (yuk) by method%% 'root' method has these limitations:%   - can make only one object%   - automatic membership in "root" group%   - automatically reuse, if it already existsis_root = ismethod(class_name, 'root');if is_root    args = {'root', 1, true, false, false};else    args = {ROOT_STRUCT.groups.name, 1, false, true, false};endif size(varargin, 2) >= 1 && iscell(varargin{1})    types = {'char', 'numeric', 'logical', 'logical', 'logical'};    ind   = 1;    while ~isempty(varargin{1}) && ind <= length(types)        if isempty(varargin{1}{1})            varargin{1}(1) = [];        elseif isa(varargin{1}{1}, types{ind})            args{ind} = varargin{1}{1};            varargin{1}(1) = [];        end        ind = ind+1;    end    if strcmp(args{1}, 'current')        args{1} = ROOT_STRUCT.groups.name;    end    varargin(1) = [];end% 'draw' method in 'remote' screenMode means make a 'remote'%   class object... requires extra argseval_name = class_name;if isfield(ROOT_STRUCT, 'screenMode') && ROOT_STRUCT.screenMode == 2 && ...        ismethod(class_name, 'draw')    eval_name = 'dXremote';end% swap to new group, if not root and different from current groupold_group = {};if ~strcmp(args{1}, ROOT_STRUCT.groups.name) %|| args{2} ~= ROOT_STRUCT.groups.index    old_group = {ROOT_STRUCT.groups.name, ROOT_STRUCT.groups.index};    rGroup(args{1:2});end% If class_name doesn't exist in top level of ROOT_STRUCT, add newif ~any(strcmp(ROOT_STRUCT.classes.names, class_name))    % Create objects ...    % we also get the matrix of attributes (name, type, default, value)    % so we can store them in ROOT_STRUCT for get/set calls    [objs, attributes, methods] = feval(eval_name, num_objects);    % No objects could be created -- just leave    if isempty(objs)        error(sprintf('Could not create %s', eval_name))    else        num_objects = length(objs);    end    % Add class to:    %   - list of class names (ROOT_STRUCT.classes.names)    %   - array of class-specific objects in ROOT_STRUCT    %   - class-specific info structs in ROOT_STRUCT.classes    %       12/8/06 jig added "root_inds" field, which is    %           the indices of objects (instances) of the given    %           class that are in the root group. This is important    %           because it allows us to keep track of which objects    %           in the active list (ROOT_STRUCT.(class_name)) to swap    %           in and out for a given group -- the ones in root    %           are always at the end of the array.    ROOT_STRUCT.classes.names        = cat(2, ROOT_STRUCT.classes.names, class_name);    ROOT_STRUCT.(class_name)         = [];    ROOT_STRUCT.classes.(class_name) = struct(...        'fieldnames',   char(attributes(:,1)), ...        'types',        cell2struct(attributes(:,2), attributes(:,1),1), ...        'ranges',       cell2struct(attributes(:,3), attributes(:,1),1), ...        'defaults',     cell2struct(attributes(:,4), attributes(:,1),1), ...        'methods',      {methods},     ...        'root_inds',    [], ...        'objects',      []);    % If it has a root method, call it for initialization (instead of set)    if is_root        objs = root(objs, varargin{:});    end    % get indices    inds_ = 1:length(objs); % indices in active array    rinds = inds_;          % rearranged indices in active array    ninds = inds_;          % indices of newly created objects in master arrayelse    % check reuse flag ... this means that if there are objects    %   already there in the current group, use them    total = length(ROOT_STRUCT.(class_name));    ri    = ROOT_STRUCT.classes.(class_name).root_inds;    gi    = setdiff(1:total, ri);    if args{3}        if isempty(args{1}) % adding root objects            inds_ = ri(1:min(length(ri), num_objects));        else                % adding group objects            inds_ = gi(1:min(length(gi), num_objects));        end        num_objects = num_objects - length(inds_);    end    % create new object(s)    if num_objects        objs = feval(eval_name, num_objects);        if isempty(objs)            error(sprintf('Could not create %s', class_name))        end        num_objects = length(objs);    end    % figure out indices. ugh.    if strcmp(args{1}, 'root')        inds_ = [inds_ total+(1:num_objects)];        rinds = 1:(total+num_objects);    else        newi  = size(gi,2)+(1:num_objects);        inds_ = [inds_ newi];        rinds = [gi newi ri];    endend% Update batch methods in:%   - list of method names (ROOT_STRUCT.methods.names)%   - method-specific lists in ROOT_STRUCT.methodsfor mt = ROOT_STRUCT.classes.(class_name).methods    if ~any(strcmp(mt{:}, ROOT_STRUCT.methods.names))        % new method        ROOT_STRUCT.methods.names   = cat(2, ROOT_STRUCT.methods.names, mt{:});        ROOT_STRUCT.methods.(mt{:}) = {class_name};    else        % Existing method ... adding class name to BEGINNING of        %   existing methods lists. This makes sure that the init        %   classes (esp. dXscreen) are at the end and thus are called LAST        %   (this is most important for calling 'done' methods)        %   don't add redundant class_name        if ~any(strcmp(ROOT_STRUCT.methods.(mt{:}), class_name))            ROOT_STRUCT.methods.(mt{:}) = ...                cat(2, class_name, ROOT_STRUCT.methods.(mt{:}));        end    end    % Check if current group is the root group -- if so,    %   add methods to ALL other groups... this way when we swap    %   in another group, its method list is already up-to-date    if strcmp(ROOT_STRUCT.groups.name, 'root')        for gr = ROOT_STRUCT.groups.names            if ~any(strcmp(mt{:}, ROOT_STRUCT.groups.(gr{:}).methods.names))                % new method                ROOT_STRUCT.groups.(gr{:}).methods.names   = ...                    cat(2, ROOT_STRUCT.groups.(gr{:}).methods.names, mt{:});                ROOT_STRUCT.groups.(gr{:}).methods.(mt{:}) = {class_name};            else                % Existing method ... adding class name to BEGINNING of                %   existing methods lists. This makes sure that the init                %   classes (esp. dXscreen) are at the end and thus are called LAST                %  (this is most important for calling 'done' methods)                %   don't add redundant class_name                if ~any(strcmp(ROOT_STRUCT.groups.(gr{:}).methods.(mt{:}), class_name))                    ROOT_STRUCT.groups.(gr{:}).methods.(mt{:}) = ...                        cat(2, class_name, ROOT_STRUCT.groups.(gr{:}).methods.(mt{:}));                end            end        end    endend%%% Store the newly created objectsif num_objects    %disp(sprintf('rAdd %d %s', num_objects, class_name))    % At the END of the current group in the active list, then    %   rearrange accordingly. These are the objects that we    %   use when calling methods (e.g., set, see below).    ROOT_STRUCT.(class_name) = cat(2, ROOT_STRUCT.(class_name), objs);    ROOT_STRUCT.(class_name) = ROOT_STRUCT.(class_name)(rinds);    % root objects will end up at the END of the current list.  So we    % neet to shift "root_inds"    ROOT_STRUCT.classes.(class_name).root_inds = ...        ROOT_STRUCT.classes.(class_name).root_inds + length(objs);    % At the END of the master list.. these are just place-holders,    %   so the array contains the total number of objects of this    %   class ever created    ROOT_STRUCT.classes.(class_name).objects = ...        cat(2, ROOT_STRUCT.classes.(class_name).objects, objs);end%%% If appropriate, call the set method with%   arguments (property/value pairs) given in varargin.if args{4}    if strcmp(eval_name, 'dXremote')        % Special case (ick) of dXremote object, in which        %   case we send in several extra args:        %   - class_name        %   - indices of these objects IN THE ACTIVE LIST        %       (this is important, because these are        %       assumed to be the same indices remotely)        %   - reuse_flag (sent to remote rAdd)        %   - save_flag (sent to remote rAdd)        ROOT_STRUCT.(class_name)(inds_) = set( ...            ROOT_STRUCT.(class_name)(inds_), class_name, ...            inds_, args, varargin{:});    else        % call set method        ROOT_STRUCT.(class_name)(inds_) = set( ...            ROOT_STRUCT.(class_name)(inds_), varargin{:});    endend%%% check whether we're saving group infoif strcmp(args{1}, 'root')    % we added root objects -- keep track of their indices    %   (in the active list) in ROOT_STRUCT.classes.(class_name).root_inds    if ~isempty(objs)        ROOT_STRUCT.classes.(class_name).root_inds = cat(2, ...            ROOT_STRUCT.classes.(class_name).root_inds, ...            size(ROOT_STRUCT.(class_name), 2) - length(objs) + (1:length(objs)));    endelse    % Save object info in the current group list. This    %   includes indices (in the master list) of all newly    %   added objects, which were added to the end    inds = size(ROOT_STRUCT.classes.(class_name).objects, 2) - ...        num_objects + (1:num_objects);    if ~isempty(inds)        % check if the number of objects we made is different than        %   the number of objects we returned... this can happen if        %   we're 're-using' any objects. If so, then the arglist        %   shouldn't be saved in the group list...        if (length(inds_) ~= length(inds) && length(inds) ~= 0) || ~args{5}            varargin = {};        end        ROOT_STRUCT.groups.(ROOT_STRUCT.groups.name)(ROOT_STRUCT.groups.index).specs = ...            cat(1, ROOT_STRUCT.groups.(ROOT_STRUCT.groups.name)(ROOT_STRUCT.groups.index).specs, ...            {class_name, inds, args{5}, varargin});    endend%%% swap the old group back inif ~isempty(old_group)    rGroup(old_group{:});end