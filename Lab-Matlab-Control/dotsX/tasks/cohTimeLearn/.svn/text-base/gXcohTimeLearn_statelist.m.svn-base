function states_ = gXcohTimeLearn_statelist(varargin)

% arguments to make statelist polymorphic
if nargin == 4

    % list of update()ables, may include dXquest
    ptrs = varargin{1};

    % viewing time may depend on Time Quest
    vtcon = varargin{2};

    % a function for picking which quest to update, in the interleaved
    % version of the task
    PQ = varargin{3};

    % info about asl
    settings = varargin{4};
else
    error('gXcohTimeLearn_statelist needs 3 arguments.')
end

% Attend/enforce FP acquisition?
if settings.useASL
    aqW = 3e4;
    aqJ = 'error';
else
    aqW = 0;
    aqJ = 'next';
end

% wait-for-response time
wait = 500;

% confirm-or-modify-response time
hang = 100;

% acquire central fixation
acquire = { ...
    'dXkbHID',  {'any', 'error'}; ...
    'dXPMDHID', {[9;11], 'error'}; ...
    'dXasl',    {[1,true,inf], 'hold', true}};

% hold central or rebound to acquire
hold = { ...
    'dXkbHID',  {'any', 'error'}; ...
    'dXPMDHID', {'any', 'error'}; ...
    'dXasl',    {[1,false,inf], 'acquire', true}};

% settle on tighter fixation or rebound to acquire
settle = { ...
    'dXkbHID',  {'any', 'error'}; ...
    'dXPMDHID', {'any', 'error'}; ...
    'dXasl',    {[2,false,inf], 'acquire', true}};

% maintain central fixation with friendly restart
fixate = { ...
    'dXkbHID',  {'any', 'error'}; ...
    'dXPMDHID', {'any', 'error'}; ...
    'dXasl',    {[2,false,inf], 'error', true}};

% pull either left or right, look anywhere
respond = { ...
    'dXkbHID',  {'f', 'left', 'j', 'right'}; ...
    'dXPMDHID', {9, 'left', 11, 'right'}; ...
    'dXasl',    {}};

% possibly pull one lever after the other
left = { ...
    'dXkbHID',  {'j', 'both'}; ...
    'dXPMDHID', {11, 'both'}; ...
    'dXasl',    {}};
right = { ...
    'dXkbHID',  {'f', 'both'}; ...
    'dXPMDHID', {9, 'both'}; ...
    'dXasl',    {}};

% correct response depends on random stimulus
%   for dXlr, 0=left, 1=right
lcon = {'jump', {'dXlr', 1, 'value'}, [0 1], {'correct'; 'incorrect'}};
rcon = {'jump', {'dXlr', 1, 'value'}, [0 1], {'incorrect'; 'correct'}};

% show dots or target
GS = @rGraphicsShow;
ind = {'dXtarget', 1};
dots = {'dXdots', 1};
noDots = {{}, 'dXdots', 1};
noFP = {'dXimage', 1:2, {}, 'dXtarget', 1};
noFPnoARR = {{},'dXimage', 1:2, {}, 'dXtarget', 1};



% move target #2 to the average eye position from the last 300ms
CT = @centerTargetOnFixation;
ctf = {2, 300};

% play beeps and custom sounds
SP = @rPlay;
bp = 'dXbeep';
sd = 'dXsound';

% update dXtc, dXlr, and sometimes dXquest
VU = @rVarUpdate;

%   name        fun args        jump    wait    repsDrawQuery   cond
arg_dXstate = {{ ...
    'clear',    {}, {},         'next', 0,      0,  5,  0,      {}; ...
    'indicate', GS, ind,        'next', 0,      0,  3,  0,      {}; ...
    'acquire',  {}, {},         aqJ,    aqW,    0,  0   acquire,{}; ...
    'hold',     {}, {},         'next', 350,    0,  0,  hold,   {}; ...
    'recenter', CT, ctf,        'next', 0,      0,  0,  1,      {}; ...
    'settle',   {}, {},         'next', 150,    0,  0,  settle, {}; ...
    % to see what levers are saying
    %'test',   rGet,  {'dXPMDHID', 1, 'values'}, 'next', 1000,    0,  0,  0, {}; ...
    ...
    'tone1',	SP, {bp,1},     'next', 100,	0,  0,  1,      {}; ...
    'pickStim',	VU, ptrs,       'next', 200,    0,  0,  1,      {}; ...
    'pickQuest',PQ, {},         'next', 200,    0,  0,  1,      {}; ...
    'onStim',	GS, dots,       'next', 400,    0,  0,  1,      {}; ...
    'ridFP',    GS, noFPnoARR,  'next',  0  ,   0,  0,  1      ,{}; ...  % matt added this line to get rid of FP
    'tone2',	SP, {bp,2},     'next', 100,	0,  0,  fixate, {}; ...
    'showStim', {}, {},         'next', 1e4,    0,  1,  1,      vtcon; ...
    'delay',    GS, noDots,     'next', 300,	0,  3,  1,      {}; ...
    ...
    'respond',  GS, noFP,       'error',wait,   0,  3,  respond,{}; ...
    'left',     {}, {},         'error',hang,	0,  0,  left,   lcon; ...
    'right',    {}, {},         'error',hang,	0,  0,  right,  rcon; ...
    'both',     {}, {},         'error',0,      0,  0,  0,      {}; ...
    ...
    'correct',  SP, {sd,1},     'end',  500,	0,  0,  0,      {}; ...
    'incorrect',SP, {sd,2},     'end',  500,	0,  0,  0,      {}; ...
    'error',    SP, {sd,3},     'next', 500,	0,  5,  0,      {}; ...
    'end',      {}, {},         'x',    0,      0,  5,  0,      {}; ...
    }};
sz = size(arg_dXstate{1}, 1);

tony = {'current', true, true, false};
states_ = {'dXstate', sz, tony, arg_dXstate};